% Generated by roxygen2 (4.0.1): do not edit by hand
\name{async_query}
\alias{async_query}
\alias{async_status}
\alias{cancel}
\alias{finish_async}
\title{Asynchronous query processing}
\usage{
async_query(sql = "", pars = NULL)

async_status()

cancel(stop_on_error = TRUE)

finish_async()
}
\arguments{
\item{sql}{a query string}

\item{pars}{a vector of parameters}

\item{stop_on_error}{call \code{\link{stop}} if cancel request cannot be issued}
}
\value{
\code{async_query}: true if query was successfully sent (an invalid query
will still return true)
\code{async_status}: a results status object, possibly indicating an
invalid query
}
\description{
Manage an asynchronous query
}
\details{
These functions expose the asynchronous query interface from
\code{libpq}. The function \code{async_query} issues a query. Its
call is identical to \code{\link{query}} except that it will return
immediately. When the issued command is ready, the function
\code{async_status} will return a query status object exactly
as \code{\link{query}}. Otherwise it will return \code{"BUSY"} to
indicate the server has not finished or \code{"DONE"} to indicate
there is nothing more to fetch.

If \code{async_status} does not return \code{"DONE"}, then
\code{finish_async} must be called to release all results. Otherwise some
result objects will leak, at least until the connection is closed. Note
that a call to \code{finish_async} may block until the server is finished
processing the command. It calls \code{cancel} internally but there is
no guarantee the command will abort.
}
\note{
In practice, you will be much better off using \code{\link{cursor}}
as that will usually return very quickly even for large queries, and has
the advantage of retrieving the results in chunks. You can call \code{cancel}
while a cursor is active. It will simply return \code{PGRES_FATAL_ERROR} is
the \code{cancel} is effective.
}
\examples{
\dontrun{
# create a database
system("createdb rpgtesting")
connect("rpgtesting")
begin()

# write data frame contents
data(mtcars)
write_table(mtcars)

# async processing on smallish result
# this wont be interesting if your machine is very fast
async_query("SELECT a.* FROM mtcars a, mtcars b")
repeat
{
  status = async_status()
  if ( status != "BUSY" ) break
  cat("busy...\\n")
  Sys.sleep(1)
}
print(status)
print(head(fetch()))
finish_async()
Sys.sleep(1)

# async processing on larger result
async_query("SELECT a.* FROM mtcars a, mtcars b, mtcars c")
count = 0
repeat
{
  status = async_status()
  if ( status == "BUSY" )
  {
    if ( count > 2 )
    {
      cat("calling cancel...\\n")
      cancel()
    }
  }
  else break
  cat("busy... \\n")
  Sys.sleep(1)
  count = count + 1
}
print(status)
finish_async()

# you can run multiple queries with async_query
rollback(); begin()
write_table(mtcars)
sql1 = "SELECT mpg FROM mtcars LIMIT 3"
sql2 = "SELECT cyl FROM mtcars LIMIT 4"
async_query(paste(sql1, sql2, sep = "; "))
while ( async_status() == "BUSY" ) NULL
print(fetch())
while ( async_status() == "BUSY" ) NULL
print(fetch())
finish_async()

# cleanup
rollback()
disconnect()
system("dropdb rpgtesting")}
}
\author{
Timothy H. Keitt
}

